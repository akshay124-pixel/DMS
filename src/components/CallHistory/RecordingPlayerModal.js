import { useState, useRef, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Box,
  Typography,
  IconButton,
  Slider,
  CircularProgress,
  Chip,
  Button,
  Divider,
} from "@mui/material";
import {
  PlayArrow,
  Pause,
  VolumeUp,
  VolumeOff,
  Close,
  GetApp,
} from "@mui/icons-material";
import api from "../../api/api";
import { toast } from "react-toastify";
import "./RecordingPlayerModal.css";

const RecordingPlayerModal = ({ open, onClose, call }) => {
  const [playing, setPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [muted, setMuted] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [recordingUrl, setRecordingUrl] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  
  const audioRef = useRef(null);
  const maxRetries = 2;
  
  useEffect(() => {
    if (open && call) {
      setError(null);
      setLoading(true);
      setRecordingUrl(null);
      setRetryCount(0);
      
      // Reset audio state
      setPlaying(false);
      setCurrentTime(0);
      setDuration(0);
      
      // Multiple strategies to get recording URL
      fetchRecordingWithFallbacks();
    }
  }, [open, call]);
  
  // Cleanup effect for blob URLs
  useEffect(() => {
    return () => {
      // Clean up blob URL when component unmounts
      if (recordingUrl && recordingUrl.startsWith('blob:')) {
        URL.revokeObjectURL(recordingUrl);
      }
    };
  }, [recordingUrl]);
  
  const fetchRecordingWithFallbacks = async () => {
    if (!call) return;
    
    // Recording fetch logged only in development
    if (process.env.NODE_ENV === 'development') {
      console.log("üéµ Fetching recording for call:", call._id, `(retry: ${retryCount})`);
      console.log("üéµ Call data:", {
        recordingUrl: call.recordingUrl ? '[URL_PRESENT]' : '[NO_URL]',
        callStatus: call.callStatus,
        duration: call.duration
      });
    }
    
    try {
      // Strategy 1: Use enhanced server-side streaming endpoint (preferred)
      if (retryCount === 0) {
        console.log("‚úÖ Strategy 1: Using enhanced server streaming endpoint");
        const streamUrl = `/api/recordings/${call._id}/stream`;
        await fetchAndCreateBlobUrl(streamUrl);
        return;
      }
      
      // Strategy 2: Use direct recording URL from call if available
      if (call.recordingUrl && call.recordingUrl.trim()) {
        console.log("‚úÖ Strategy 2: Using direct recording URL");
        
        // For Smartflo URLs, try both direct and blob approaches
        if (call.recordingUrl.startsWith('http') && call.recordingUrl.includes('cloudphone')) {
          
          // On second attempt, try blob conversion for better compatibility
          if (retryCount === 1) {
            console.log("üîÑ Second attempt: Using blob conversion for Smartflo URL");
            await fetchAndCreateBlobUrl(call.recordingUrl);
            return;
          } else {
            // On final retry, try direct URL
            console.log("üîÑ Final retry: Using direct Smartflo URL");
            setRecordingUrl(call.recordingUrl);
            setLoading(false);
            return;
          }
        }
        
        // For other URLs, try blob approach
        await fetchAndCreateBlobUrl(call.recordingUrl);
        return;
      }
      
      // Strategy 3: Fetch from recording metadata API
      console.log("üîÑ Strategy 3: Fetching from metadata API");
      const metadataResponse = await api.get(`/api/recordings/${call._id}`);
      
      if (metadataResponse.data.success && metadataResponse.data.data?.recordingUrl) {
        console.log("‚úÖ Strategy 3: Got URL from metadata");
        
        // Use the stream URL if available
        if (metadataResponse.data.data.streamUrl) {
          await fetchAndCreateBlobUrl(metadataResponse.data.data.streamUrl);
          return;
        }
        
        // Check if it's a Smartflo URL
        if (metadataResponse.data.data.recordingUrl.startsWith('http') && 
            metadataResponse.data.data.recordingUrl.includes('cloudphone')) {
          
          if (retryCount === 0) {
            console.log("üîÑ Using blob conversion for Smartflo URL from metadata");
            await fetchAndCreateBlobUrl(metadataResponse.data.data.recordingUrl);
            return;
          } else {
            console.log("üîÑ Using direct Smartflo URL from metadata");
            setRecordingUrl(metadataResponse.data.data.recordingUrl);
            setLoading(false);
            return;
          }
        }
        
        await fetchAndCreateBlobUrl(metadataResponse.data.data.recordingUrl);
        return;
      }
      
      throw new Error("No recording URL available from any source");
      
    } catch (error) {
      console.error("‚ùå All recording fetch strategies failed:", error);
      
      // Final fallback: Check if call should have recording
      if (call.duration > 0 && (call.callStatus === "completed" || call.callStatus === "answered")) {
        setError("Recording should be available but cannot be accessed. The recording may be processing, expired, or temporarily unavailable. Please try again later or contact support.");
      } else {
        setError("No recording available for this call. Calls must be completed/answered and have duration > 0 to be recorded.");
      }
      setLoading(false);
    }
  };
  
  const fetchAndCreateBlobUrl = async (url) => {
    console.log("üéµ Fetching audio data with authentication:", url);
    
    try {
      // Build full URL if relative
      let fetchUrl = url;
      if (url.startsWith('/api/')) {
        fetchUrl = `${process.env.REACT_APP_URL || 'http://localhost:4000'}${url}`;
      }
      
      console.log("üîó Final fetch URL:", fetchUrl);
      
      // Fetch audio data with authentication and enhanced headers
      const response = await fetch(fetchUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Accept': 'audio/*,*/*;q=0.9',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
        },
      });
      
      // Response details logged only in development
      if (process.env.NODE_ENV === 'development') {
        console.log("üì° Response status:", response.status);
      }
      
      if (!response.ok) {
        let errorText = "Unknown error";
        try {
          const errorData = await response.json();
          errorText = errorData.message || errorData.error || response.statusText;
        } catch {
          errorText = await response.text() || response.statusText;
        }
        console.error("‚ùå Response error:", errorText);
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
      }
      
      // Check content type
      const contentType = response.headers.get('content-type');
      console.log("üéµ Content-Type:", contentType);
      
      // Validate that we received audio content
      if (contentType && !contentType.includes('audio') && !contentType.includes('application/octet-stream')) {
        console.warn("‚ö†Ô∏è Unexpected content type:", contentType);
        // Continue anyway, might still be audio
      }
      
      // Get the audio blob
      const audioBlob = await response.blob();
      console.log("‚úÖ Audio blob created:", {
        size: audioBlob.size,
        type: audioBlob.type
      });
      
      // Validate blob size
      if (audioBlob.size === 0) {
        throw new Error("Received empty audio file");
      }
      
      // Create blob with proper MIME type for better compatibility
      let finalBlob = audioBlob;
      if (!audioBlob.type || audioBlob.type === '') {
        // Try multiple MIME types for better compatibility
        finalBlob = new Blob([audioBlob], { type: 'audio/mpeg' });
        console.log("üîß Fixed blob MIME type to audio/mpeg");
      } else if (audioBlob.type.includes('audio/mp3') || audioBlob.type.includes('audio/x-mpeg')) {
        // Normalize MP3 MIME types to standard audio/mpeg
        finalBlob = new Blob([audioBlob], { type: 'audio/mpeg' });
        console.log("üîß Normalized MIME type to audio/mpeg from:", audioBlob.type);
      } else if (audioBlob.type === 'application/octet-stream') {
        // Generic binary type - assume MP3
        finalBlob = new Blob([audioBlob], { type: 'audio/mpeg' });
        console.log("üîß Converted octet-stream to audio/mpeg");
      }
      
      // Additional validation for audio content
      if (audioBlob.size < 100) {
        throw new Error("Audio file too small - likely corrupted or empty");
      }
      
      // Create blob URL
      const blobUrl = URL.createObjectURL(finalBlob);
      console.log("‚úÖ Blob URL created:", blobUrl);
      
      setRecordingUrl(blobUrl);
      setLoading(false);
      
    } catch (error) {
      console.error("‚ùå Failed to fetch audio data:", error);
      throw error;
    }
  };
  
  const handlePlayPause = async () => {
    if (!audioRef.current) {
      console.error("üéµ Audio ref not available");
      return;
    }
    
    try {
      if (playing) {
        console.log("üéµ Pausing audio");
        audioRef.current.pause();
        setPlaying(false);
      } else {
        console.log("üéµ Playing audio");
        console.log("üéµ Audio element state:", {
          src: audioRef.current.src,
          readyState: audioRef.current.readyState,
          networkState: audioRef.current.networkState,
          paused: audioRef.current.paused,
          currentTime: audioRef.current.currentTime,
          duration: audioRef.current.duration
        });
        
        const playPromise = audioRef.current.play();
        
        if (playPromise !== undefined) {
          await playPromise;
          setPlaying(true);
          console.log("‚úÖ Audio started playing");
        }
      }
    } catch (error) {
      console.error("üéµ Play/Pause error:", error);
      setPlaying(false);
      
      // Provide user feedback for common play errors
      if (error.name === 'NotAllowedError') {
        toast.error("Audio playback blocked by browser. Please click play again.");
      } else if (error.name === 'NotSupportedError') {
        toast.error("Audio format not supported. Try downloading the recording.");
      } else {
        toast.error("Audio playback failed. Please try again.");
      }
    }
  };
  
  const handleTimeUpdate = () => {
    if (audioRef.current) {
      const currentTime = audioRef.current.currentTime;
      setCurrentTime(currentTime);
      console.log("üéµ Time update:", currentTime, "/", audioRef.current.duration);
    }
  };
  
  const handleLoadedMetadata = () => {
    if (audioRef.current) {
      const duration = audioRef.current.duration;
      setDuration(duration);
      setLoading(false);
      console.log("‚úÖ Audio metadata loaded - Duration:", duration);
    }
  };
  
  const handleCanPlay = () => {
    console.log("‚úÖ Audio can start playing");
    setLoading(false);
  };
  
  const handlePlay = () => {
    console.log("‚úÖ Audio play event fired");
    setPlaying(true);
  };
  
  const handlePause = () => {
    console.log("‚è∏Ô∏è Audio pause event fired");
    setPlaying(false);
  };
  
  const handleEnded = () => {
    console.log("üèÅ Audio ended");
    setPlaying(false);
    setCurrentTime(0);
  };
  
  const handleSeek = (event, newValue) => {
    if (audioRef.current) {
      audioRef.current.currentTime = newValue;
      setCurrentTime(newValue);
    }
  };
  
  const handleVolumeChange = (event, newValue) => {
    if (audioRef.current) {
      audioRef.current.volume = newValue;
      setVolume(newValue);
      setMuted(newValue === 0);
    }
  };
  
  const handleMuteToggle = () => {
    if (audioRef.current) {
      audioRef.current.muted = !muted;
      setMuted(!muted);
    }
  };
  
  const handleError = (e) => {
    console.error("üéµ Audio playback error:", e);
    console.error("üéµ Audio element details:", {
      error: e.target?.error,
      networkState: e.target?.networkState,
      readyState: e.target?.readyState,
      src: e.target?.src,
      errorCode: e.target?.error?.code,
      errorMessage: e.target?.error?.message,
      currentSrc: e.target?.currentSrc,
      duration: e.target?.duration,
      paused: e.target?.paused,
      ended: e.target?.ended
    });
    
    // Log additional debugging info
    console.error("üéµ Recording URL info:", {
      recordingUrl,
      isBlob: recordingUrl?.startsWith('blob:'),
      audioSrc: e.target?.src
    });
    
    // Provide specific error messages based on error type
    let errorMessage = "Failed to load recording. ";
    let debugInfo = "";
    
    if (e.target?.error?.code === 1) {
      errorMessage += "The recording download was aborted.";
      debugInfo = "MEDIA_ERR_ABORTED";
    } else if (e.target?.error?.code === 2) {
      errorMessage += "A network error occurred while downloading the recording.";
      debugInfo = "MEDIA_ERR_NETWORK";
    } else if (e.target?.error?.code === 3) {
      errorMessage += "The recording format is not supported by your browser. This may be due to codec issues or corrupted audio data.";
      debugInfo = "MEDIA_ERR_DECODE";
    } else if (e.target?.error?.code === 4) {
      errorMessage += "The recording source is not available or accessible.";
      debugInfo = "MEDIA_ERR_SRC_NOT_SUPPORTED";
    } else {
      errorMessage += "The recording may be unavailable, expired, or in an unsupported format.";
      debugInfo = "UNKNOWN_ERROR";
    }
    
    console.error("üéµ Error classification:", debugInfo);
    
    // For MEDIA_ERR_DECODE, try alternative approaches
    if (e.target?.error?.code === 3 && retryCount < maxRetries) {
      if (process.env.NODE_ENV === 'development') {
        console.log(`üîÑ MEDIA_ERR_DECODE: Trying alternative approach (retry ${retryCount + 1}/${maxRetries})`);
      }
      
      // Clean up failed blob URL
      if (recordingUrl?.startsWith('blob:')) {
        URL.revokeObjectURL(recordingUrl);
      }
      setRecordingUrl(null);
      setError(null);
      setLoading(true);
      setRetryCount(prev => prev + 1);
      
      // Try direct URL approach for Smartflo recordings
      if (call?.recordingUrl?.startsWith('http') && call.recordingUrl.includes('cloudphone')) {
        console.log("üîÑ Using direct Smartflo URL as decode fallback");
        setTimeout(() => {
          setRecordingUrl(call.recordingUrl);
          setLoading(false);
        }, 500);
        return;
      }
      
      // Otherwise retry with different blob approach
      setTimeout(() => {
        fetchRecordingWithFallbacks();
      }, 1000);
      
      return; // Don't set error state yet, let retry happen
    }
    
    // Check if it's other blob URL issues
    if (recordingUrl?.startsWith('blob:') && e.target?.error?.code === 4 && retryCount < maxRetries) {
      errorMessage += " The audio blob may be corrupted or invalid. Retrying...";
      
      // Try to revoke and recreate blob URL
      if (process.env.NODE_ENV === 'development') {
        console.log(`üîÑ Attempting to recreate blob URL (retry ${retryCount + 1}/${maxRetries})...`);
      }
      URL.revokeObjectURL(recordingUrl);
      setRecordingUrl(null);
      setError(null);
      setLoading(true);
      setRetryCount(prev => prev + 1);
      
      // Retry with a delay
      setTimeout(() => {
        fetchRecordingWithFallbacks();
      }, 1000);
      
      return; // Don't set error state yet, let retry happen
    }
    
    // Final error state
    setError(errorMessage);
    setLoading(false);
    setPlaying(false);
    
    // Show user-friendly toast message
    if (debugInfo === "MEDIA_ERR_DECODE") {
      toast.error("Audio format not supported. Try downloading the recording instead.");
    } else {
      toast.error(`Recording playback failed: ${debugInfo}`);
    }
  };
  
  const handleDownload = async () => {
    if (!call) {
      toast.error("No call information available");
      return;
    }
    
    try {
      let downloadUrl = recordingUrl;
      
      // If no recording URL is set, try to use the original call recording URL
      if (!downloadUrl && call.recordingUrl) {
        downloadUrl = call.recordingUrl;
      }
      
      if (!downloadUrl) {
        toast.error("No recording URL available for download");
        return;
      }
      
      // Create download link
      const link = document.createElement("a");
      link.href = downloadUrl;
      link.setAttribute("download", `recording-${call._id}-${Date.now()}.mp3`);
      link.setAttribute("target", "_blank");
      link.setAttribute("rel", "noopener noreferrer");
      document.body.appendChild(link);
      link.click();
      link.remove();
      
      toast.success("Recording download started - check your downloads folder");
    } catch (error) {
      console.error("Download error:", error);
      toast.error("Failed to download recording");
    }
  };
  
  const formatTime = (seconds) => {
    if (!seconds || isNaN(seconds)) return "00:00";
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };
  
  const handleClose = () => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
    }
    setPlaying(false);
    setCurrentTime(0);
    setError(null);
    setRetryCount(0);
    
    // Clean up blob URL to prevent memory leaks
    if (recordingUrl && recordingUrl.startsWith('blob:')) {
      URL.revokeObjectURL(recordingUrl);
    }
    
    setRecordingUrl(null);
    onClose();
  };
  
  if (!call) return null;
  
  // Determine the audio source URL
  let audioSrc = recordingUrl; // Now recordingUrl is already a blob URL or direct URL
  
  console.log("Audio source URL:", audioSrc);
  
  const getStatusColor = (status) => {
    const colors = {
      completed: "success",
      answered: "info",
      failed: "error",
      no_answer: "warning",
      busy: "warning",
      cancelled: "default",
    };
    return colors[status] || "default";
  };

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="sm"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: "15px",
        },
      }}
    >
      <DialogTitle
        sx={{
          background: "linear-gradient(90deg, #6a11cb 0%, #2575fc 100%)",
          color: "white",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          padding: "20px 24px",
        }}
      >
        <Typography variant="h6" sx={{ fontWeight: "600" }}>
          Call Recording
        </Typography>
        <IconButton
          onClick={handleClose}
          size="small"
          sx={{
            color: "white",
            "&:hover": { backgroundColor: "rgba(255,255,255,0.2)" },
          }}
        >
          <Close />
        </IconButton>
      </DialogTitle>

      <DialogContent sx={{ padding: "24px", backgroundColor: "#f5f7fa" }}>
        {/* Call Details */}
        <Box
          sx={{
            backgroundColor: "white",
            borderRadius: "12px",
            padding: "20px",
            mb: 3,
            boxShadow: "0 2px 8px rgba(0,0,0,0.08)",
          }}
        >
          <Box sx={{ mb: 2 }}>
            <Typography variant="caption" color="textSecondary">
              Customer
            </Typography>
            <Typography variant="body1" sx={{ fontWeight: "600" }}>
              {call.leadId?.contactName || call.leadId?.customerName || "N/A"}
            </Typography>
          </Box>

          <Box sx={{ mb: 2 }}>
            <Typography variant="caption" color="textSecondary">
              Phone Number
            </Typography>
            <Typography variant="body1" sx={{ fontWeight: "600" }}>
              {call.destinationNumber}
            </Typography>
          </Box>

          <Box sx={{ mb: 2 }}>
            <Typography variant="caption" color="textSecondary">
              Date & Time
            </Typography>
            <Typography variant="body2">
              {new Date(call.createdAt).toLocaleString()}
            </Typography>
          </Box>

          <Box sx={{ mb: 2 }}>
            <Typography variant="caption" color="textSecondary">
              Duration
            </Typography>
            <Typography variant="body1" sx={{ fontWeight: "600" }}>
              {formatTime(call.duration)}
            </Typography>
          </Box>

          <Box>
            <Chip
              label={call.callStatus}
              color={getStatusColor(call.callStatus)}
              size="small"
              sx={{ textTransform: "capitalize" }}
            />
          </Box>
        </Box>

        <Divider sx={{ mb: 3 }} />

        {/* Audio Player */}
        <Box
          sx={{
            backgroundColor: "white",
            borderRadius: "12px",
            padding: "20px",
            boxShadow: "0 2px 8px rgba(0,0,0,0.08)",
          }}
        >
          {loading ? (
            <Box sx={{ textAlign: "center", py: 3 }}>
              <CircularProgress sx={{ mb: 2 }} />
              <Typography variant="body2" color="textSecondary">
                Loading recording...
              </Typography>
            </Box>
          ) : error ? (
            <Box sx={{ textAlign: "center", py: 3 }}>
              <Typography color="error" variant="body2" sx={{ mb: 1 }}>
                ‚ö†Ô∏è Recording Unavailable
              </Typography>
              <Typography variant="caption" color="textSecondary" sx={{ mb: 2, display: "block" }}>
                {error}
              </Typography>
              {call?.recordingUrl && (
                <Button
                  variant="outlined"
                  size="small"
                  onClick={handleDownload}
                  startIcon={<GetApp />}
                  sx={{
                    mt: 1,
                    borderColor: "#2575fc",
                    color: "#2575fc",
                    "&:hover": {
                      borderColor: "#1565e8",
                      backgroundColor: "rgba(37, 117, 252, 0.04)"
                    }
                  }}
                >
                  Try Direct Download
                </Button>
              )}
            </Box>
          ) : !audioSrc ? (
            <Box sx={{ textAlign: "center", py: 3 }}>
              <Typography color="warning.main" variant="body2" sx={{ mb: 1 }}>
                üìµ No Recording Available
              </Typography>
              <Typography variant="caption" color="textSecondary">
                This call was not recorded or the recording is not accessible.
              </Typography>
            </Box>
          ) : (
            <>
              <audio
                ref={audioRef}
                src={audioSrc}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onCanPlay={handleCanPlay}
                onPlay={handlePlay}
                onPause={handlePause}
                onEnded={handleEnded}
                onError={handleError}
                preload="metadata"
                controls={false}
                {...(audioSrc?.startsWith('blob:') ? {} : 
                     audioSrc?.includes('cloudphone') ? {} : 
                     { crossOrigin: "anonymous" })}
              >
                {/* Fallback sources for better compatibility */}
                {audioSrc && (
                  <>
                    <source src={audioSrc} type="audio/mpeg" />
                    <source src={audioSrc} type="audio/mp3" />
                    <source src={audioSrc} type="audio/wav" />
                    <source src={audioSrc} type="audio/ogg" />
                  </>
                )}
                Your browser does not support the audio element.
              </audio>

              {/* Progress Bar */}
              <Box sx={{ mb: 2 }}>
                <Slider
                  value={currentTime}
                  max={duration || 100}
                  onChange={handleSeek}
                  disabled={loading || !!error}
                  sx={{
                    color: "#6a11cb",
                    "& .MuiSlider-thumb": {
                      width: 16,
                      height: 16,
                    },
                  }}
                />
                <Box display="flex" justifyContent="space-between">
                  <Typography variant="caption" color="textSecondary">
                    {formatTime(currentTime)}
                  </Typography>
                  <Typography variant="caption" color="textSecondary">
                    {formatTime(duration)}
                  </Typography>
                </Box>
              </Box>

              {/* Controls */}
              <Box
                display="flex"
                alignItems="center"
                justifyContent="center"
                gap={2}
              >
                <IconButton
                  onClick={handlePlayPause}
                  disabled={loading || !!error}
                  sx={{
                    width: 56,
                    height: 56,
                    background: "linear-gradient(135deg, #6a11cb 0%, #2575fc 100%)",
                    color: "white",
                    "&:hover": {
                      background: "linear-gradient(135deg, #5a0fb7 0%, #1565e8 100%)",
                    },
                    "&:disabled": {
                      background: "#e0e0e0",
                      color: "#9e9e9e",
                    },
                  }}
                >
                  {loading ? (
                    <CircularProgress size={24} sx={{ color: "white" }} />
                  ) : playing ? (
                    <Pause />
                  ) : (
                    <PlayArrow />
                  )}
                </IconButton>

                <Box display="flex" alignItems="center" gap={1} sx={{ minWidth: 150 }}>
                  <IconButton onClick={handleMuteToggle} size="small">
                    {muted ? <VolumeOff /> : <VolumeUp />}
                  </IconButton>
                  <Slider
                    value={muted ? 0 : volume}
                    onChange={handleVolumeChange}
                    min={0}
                    max={1}
                    step={0.1}
                    sx={{
                      width: 100,
                      color: "#6a11cb",
                      "& .MuiSlider-thumb": {
                        width: 12,
                        height: 12,
                      },
                    }}
                  />
                </Box>
              </Box>
              
              {/* Recording Info */}
              {/* <Box sx={{ mt: 2, p: 2, backgroundColor: "#f8f9fa", borderRadius: "8px" }}>
                <Typography variant="caption" color="textSecondary" display="block">
                  Recording Source: {
                    audioSrc?.startsWith('blob:') ? 'Authenticated Stream' : 
                    audioSrc?.includes('cloudphone') ? 'Smartflo Direct' :
                    audioSrc?.includes('smartflo') ? 'Smartflo' : 
                    'Local Server'
                  }
                </Typography>
                <Typography variant="caption" color="textSecondary" display="block">
                  Format: MP3 ‚Ä¢ Quality: Standard ‚Ä¢ {audioSrc?.startsWith('blob:') ? 'Authentication: ‚úÖ Secured' : 'Direct URL: ‚úÖ Token-based'}
                </Typography>
                <Typography variant="caption" color="textSecondary" display="block">
                  Debug: Retry Count: {retryCount} ‚Ä¢ URL Type: {
                    recordingUrl?.startsWith('blob:') ? 'Blob' : 
                    recordingUrl?.startsWith('http') ? 'Direct' : 
                    'API'
                  } ‚Ä¢ Playing: {playing ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}
                </Typography>
                <Typography variant="caption" color="textSecondary" display="block">
                  Audio State: Ready: {audioRef.current?.readyState || 0} ‚Ä¢ Network: {audioRef.current?.networkState || 0} ‚Ä¢ Paused: {audioRef.current?.paused ? 'Yes' : 'No'}
                </Typography>
              </Box> */}
            </>
          )}
        </Box>
      </DialogContent>

      <DialogActions sx={{ padding: "16px 24px", backgroundColor: "#f5f7fa" }}>
        <Button
          onClick={handleDownload}
          startIcon={<GetApp />}
          disabled={!!error || !recordingUrl}
          sx={{
            background: "linear-gradient(90deg, #43e97b 0%, #38f9d7 100%)",
            color: "white",
            textTransform: "none",
            fontWeight: "600",
            padding: "8px 20px",
            borderRadius: "8px",
            "&:hover": {
              background: "linear-gradient(90deg, #38d66c 0%, #2de0c8 100%)",
            },
            "&:disabled": {
              background: "#e0e0e0",
              color: "#9e9e9e",
            },
          }}
        >
          Download
        </Button>
        <Button
          onClick={handleClose}
          sx={{
            background: "linear-gradient(90deg, #6a11cb 0%, #2575fc 100%)",
            color: "white",
            textTransform: "none",
            fontWeight: "600",
            padding: "8px 20px",
            borderRadius: "8px",
            "&:hover": {
              background: "linear-gradient(90deg, #5a0fb7 0%, #1565e8 100%)",
            },
          }}
        >
          Close
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default RecordingPlayerModal;
